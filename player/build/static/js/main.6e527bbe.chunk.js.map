{"version":3,"sources":["ReactPlayerWrapper.js","player/Sections.js","player/ImageAreas.js","player/SectionPages.js","player/Player.js","ImagesLoader.js","index.js"],"names":["ReactPlayerWrapper","props","state","progress","duration","gotoAfterStopSec","endSec","playing","playbackSpeed","showControls","$player","React","createRef","this","setState","current","seekTo","playedSeconds","_stopAndReturn","onProgressUpdate","onPlay","onStop","speed","target","value","startSec","mode","Math","max","className","ref","url","videoUrl","width","height","onDuration","_handleDuration","bind","onProgress","_handleProgress","_handleOnPlay","onStart","_handleOnStart","progressInterval","onPause","_handleStop","onEnded","playbackRate","controls","config","youtube","playerVars","origin","window","location","secsToString","onChange","_handleOnSelect","map","key","Component","Sections","sections","playInterval","activeSections","playInput","setPlayInput","onPlayInputChange","e","handleClickSection","sectionIdx","parseSectionPoint","str","split","join","number","parseInt","length","console","error","secondsShift","trim","isNaN","parseFloat","isNumeric","parsedPlayInput","replace","fromSectionStr","untilSectionStr","fromSection","fromSectionDelta","untilSection","untilSectionDelta","isSectionInPlayInput","idx","parsed","tabIndex","indexOf","onClick","id","src","align","data-tip","data-for","startSectionIdx","startSectionIdxDelta","stopSectionIdx","stopSectionIdxDelta","ImageAreas","coeffOrigImageToScreenCoords","title","image","areas","onImageClicked","canvasRef","useRef","drawCanvas","context","getContext","drawImage","forEach","a","fillStyle","fillRect","x","y","useEffect","canvas","event","rect","getBoundingClientRect","clientX","left","clientY","top","getCursorPosition","SectionPages","images","pages","sectionPageAreas","skipScrollingFromTime","onPageClicked","useState","zoom","setZoom","lastScrollHash","setLastScrollHash","sectionPagesRef","findScrollareaNode","i","childNodes","calculatePageHeight","shouldSkipScrolling","Date","getTime","handleScrolling","hash","JSON","stringify","updateHash","selectedPageIdx","puid","findFirstSelectedPageIdx","page","container","invariant","findPageNode","scrollTop","offsetTop","Object","keys","sectionPagesStyles","style","p","imageX","imageY","imageIdx","pageId","Player","setActiveSections","initialised","setInitialised","setSkipScrollingFromTime","refreshSkipScrollingOnPlay","setRefreshSkipScrollingOnPlaying","setVideoPlayerPosSecs","handlePlayInterval","from","until","playSection","updateActiveSections","newActiveSections","section","push","sectionContainsPoint","pageAreas","posX","posY","areaIdx","x2","y2","min","pageUid","pageX","pageY","concat","getActivePageAreas","toFixed","imageUrls","onImagesLoaded","Array","fill","setProgress","interval","setInterval","delta","random","parse","totalLoaded","onImageLoaded","clearInterval","imageUrl","Image","onload","onerror","percent","reduce","prevVal","currVal","renderProgress","initSectionsPlayer","$element","data","ReactDOM","render","StrictMode","ImagesLoader","transformFromHumanReadable"],"mappings":"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","file":"static/js/main.6e527bbe.chunk.js","sourcesContent":["import React, { useState, useRef, useEffect } from 'react';\nimport ReactPlayer from 'react-player';\n\nimport { secsToString } from 'emptybars-common/utils'\n\nimport './ReactPlayerWrapper.scss';\n\nclass ReactPlayerWrapper extends React.Component {\n\n    constructor(props) {\n        super(props);\n        this.state = {\n            progress: -1,\n            duration: -1,\n            gotoAfterStopSec: -1,\n            endSec: -1,\n            playing: false,\n            playbackSpeed: 100,\n            showControls: false,\n        };\n        this.$player = React.createRef();\n    }\n\n    _handleDuration(duration) {\n        this.setState({duration: duration});\n    }\n\n    _stopAndReturn() {\n        const gotoAfterStopSec = this.state.gotoAfterStopSec;\n        this.setState({\n            endSec: -1,\n            gotoAfterStopSec: -1,\n            playing: false\n        });\n        this.$player.current.seekTo(gotoAfterStopSec, 'seconds');\n    }\n\n    _handleProgress({ playedSeconds }) {\n        if (this.state.endSec > 0 && playedSeconds > this.state.endSec) {\n            this._stopAndReturn();\n        }\n        this.setState({progress: playedSeconds});\n        this.props.onProgressUpdate(playedSeconds);\n    };\n\n    _handleOnPlay() {\n        if (!this.state.playing) {\n            this.setState({\n                playing: true,\n                endSec: -1,\n                gotoAfterStopSec: -1\n            });\n        }\n    }\n\n    _handleOnStart() {\n        this.setState({showControls: true});\n        this.props.onPlay();\n    }\n\n    _handleStop() {\n        this.setState({playing: false});\n        this.props.onStop();\n    }\n\n    _handleOnSelect(speed) {\n        this.setState({playbackSpeed: speed.target.value});\n    }\n\n    playSection(startSec, endSec, mode) {\n        this.$player.current.seekTo(startSec, 'seconds');\n        this.setState({\n            // TODO: remove magic strings\n            gotoAfterStopSec: Math.max(mode === 'STAY_AT_END' ? endSec : startSec, 0),\n            endSec: Math.max(endSec, 0.01),\n            playing: true\n        });\n    }\n\n    render() {\n            const playbackSpeeds = [25, 50, 60, 70, 80, 90, 100, 125, 150, 200];\n            return (\n                <div className='playWithNavButtons'>\n                    <ReactPlayer\n                        ref={this.$player}\n                        url={this.props.videoUrl}\n                        width='100%'\n                        height='100%'\n                        onDuration={this._handleDuration.bind(this)}\n                        onProgress={this._handleProgress.bind(this)}\n                        onPlay={this._handleOnPlay.bind(this)}\n                        onStart={this._handleOnStart.bind(this)}\n                        progressInterval={100}\n                        onPause={this._handleStop.bind(this)}\n                        onEnded={this._handleStop.bind(this)}\n                        playbackRate={this.state.playbackSpeed / 100.0}\n                        playing={this.state.playing}\n                        controls={true}\n                        config={{\n                            youtube: {\n                                playerVars: {origin: window.location.origin}\n                            }\n                        }}\n                    />\n                    {this.state.showControls\n                        ?\n                        <div className='positionAndControls'>\n                            Current position: <span className='position'>{secsToString(this.state.progress)}</span>\n                            <br/>\n                            Playback speed:\n                            <select value={this.state.playbackSpeed} onChange={this._handleOnSelect.bind(this)}>\n                                {playbackSpeeds.map((speed) =>\n                                    <option key={`option${speed}`} value={speed}>{speed}%</option>\n                                )}\n                            </select>\n                        </div>\n                        :\n                        ''\n                    }\n                </div>\n            );\n    }\n}\n\nexport default ReactPlayerWrapper;","import React, {useState, useRef, useEffect} from 'react';\nimport { secsToString } from \"emptybars-common/utils\";\nimport ReactTooltip from 'react-tooltip';\nimport './Sections.scss';\n\nfunction Sections({ sections, playInterval, activeSections, playInput, setPlayInput }) {\n    const onPlayInputChange = (e) => {\n        setPlayInput(e.target.value);\n    }\n\n    const handleClickSection = (sectionIdx) => {\n        onPlayInputChange({\n            target: {\n                value: (sectionIdx+1) + ':' + (sectionIdx+1)\n            }\n        });\n        playInterval(sections[sectionIdx].startSec, sections[sectionIdx].endSec);\n    };\n\n    const handlePlayClick = () => {\n        const [startSectionIdx, startSectionIdxDelta, stopSectionIdx, stopSectionIdxDelta] = parsedPlayInput();\n        playInterval(\n            sections[startSectionIdx-1].startSec + startSectionIdxDelta,\n            sections[stopSectionIdx-1].endSec + stopSectionIdxDelta\n        )\n    }\n\n    function isNumeric(str) {\n        if (typeof str != \"string\") return false // we only process strings!\n        return !isNaN(str) && // use type coercion to parse the _entirety_ of the string (`parseFloat` alone does not do this)...\n            !isNaN(parseFloat(str)) // ...and ensure strings of whitespace fail\n    }\n\n    const parseSectionPoint = (str) => {\n        str = str.split('-').join('+-');\n        const split = str.split('+');\n        const number = parseInt(split[0]);\n        if (number != split[0]) {\n            return [false, false];\n        }\n        if (number <= 0 || number > sections.length) {\n            console.error(\"Section \" + number + \" is out of range. Max=\" + sections.length)\n            return [false, false];\n        }\n        if (split.length == 1) {\n            return [number, 0];\n        } else if (split.length == 2) {\n            const secondsShift = split[1].split('s').join('').trim()\n            if (!isNumeric(secondsShift)) {\n                console.error(secondsShift + \" is not a number\");\n                return [false, false];\n            }\n            return [number, parseFloat(secondsShift)];\n        } else {\n            return [false, false];\n        }\n    }\n\n    const parsedPlayInput = () => {\n        const split = playInput.replace(' ', '').split(':');\n        if (split.length != 2) {\n            return false;\n        }\n        const fromSectionStr = split[0];\n        const untilSectionStr = split[1];\n        var [fromSection, fromSectionDelta] = parseSectionPoint(fromSectionStr);\n        if (!fromSection) {\n            return false;\n        }\n        var [untilSection, untilSectionDelta] = parseSectionPoint(untilSectionStr);\n        if (!untilSection) {\n            return false;\n        }\n        return [fromSection, fromSectionDelta, untilSection, untilSectionDelta];\n    }\n\n    const isSectionInPlayInput = (idx) => {\n        const parsed = parsedPlayInput();\n        if (parsed) {\n            const [fromSection, fromSectionDelta, untilSection, untilSectionDelta] = parsed;\n            return (fromSection <= (idx+1) && untilSection >= (idx+1));\n        }\n        return false;\n    }\n\n    return (\n        <div className='sections'>\n            <div>Sections:</div>\n            <div className='scrolling'>\n\n                {sections.map(({ startSec, endSec }, key) => (\n                    <div\n                        tabIndex={0}\n                        className={`button ${\n                            (activeSections.indexOf(key) >= 0) ? 'active' : ''\n                        } ${isSectionInPlayInput(key) ? 'inPlayInput' : ''}`}\n                        key={key}\n                        onClick={handleClickSection.bind(null, key)}\n                    >\n                        #{key+1}\n                    </div>\n                ))}\n            </div>\n            <div className='playSectionsSection'>\n                Play sections: <input onChange={onPlayInputChange} value={playInput} className={parsedPlayInput() ? '' : 'errorInput'}/>\n                <ReactTooltip id='formats'>\n                    <div>\n                        <div>Allowed formats:\n                            <ul className='allowedFormats'>\n                             <li><span>1:1</span> - play section 1 </li>\n                             <li><span>1:3</span> - play sections 1, 2 and 3</li>\n                             <li><span>1-10s:2+15.2s</span> - play sections 1 and 2, <br />but start 10 seconds earlier and finish 15.2\n                            seconds later</li>\n                            </ul>\n                        </div>\n                    </div>\n                </ReactTooltip>\n                &nbsp; <img src='https://images2.imgbox.com/02/01/VzjEL9yb_o.png?download=true' align='center' data-tip data-for='formats' />\n            </div>\n            {!parsedPlayInput()\n                ? ''\n                : <button onClick={handlePlayClick}>Play</button>\n            }\n         </div>);\n}\n\nexport default Sections;\n","import React, { useState, useRef, useEffect } from 'react';\n\nimport './ImageAreas.scss';\n\nfunction ImageAreas({ title, image, width, areas, onImageClicked }) {\n    // var [height, setHeight] = useState(100);\n    var canvasRef = useRef(null);\n    var coeffOrigImageToScreenCoords;\n    var height;\n\n    if (image && image.width && image.height) {\n        coeffOrigImageToScreenCoords = (width * 1.0 / image.width);\n        height = parseInt(image.height * coeffOrigImageToScreenCoords);\n    } else {\n        coeffOrigImageToScreenCoords = -1;\n        height = -1;\n    }\n\n    const drawCanvas = () => {\n        if (image && image.width && image.height && canvasRef && canvasRef.current) {\n            const context = canvasRef.current.getContext(\"2d\");\n            context.drawImage(image, 0, 0, image.width, image.height, 0, 0, width, height);\n\n            areas.forEach((a, idx) => {\n                context.fillStyle = 'rgba(255, 255, 0, 0.5)';\n                context.fillRect(a.x * coeffOrigImageToScreenCoords, a.y * coeffOrigImageToScreenCoords, a.width * coeffOrigImageToScreenCoords, a.height * coeffOrigImageToScreenCoords);\n            });\n        }\n    }\n\n    function getCursorPosition(canvas, event) {\n        const rect = canvas.getBoundingClientRect()\n        const x = event.clientX - rect.left\n        const y = event.clientY - rect.top\n        return [x, y]\n    }\n\n    const handleMouseClick = (e) => {\n        const [x, y] = getCursorPosition(canvasRef.current, e);\n        const origX = x / coeffOrigImageToScreenCoords;\n        const origY = y / coeffOrigImageToScreenCoords;\n        onImageClicked(origX, origY);\n    }\n\n    useEffect(() => {\n        drawCanvas();\n    });\n\n    if (image && image.width && image.height) {\n        drawCanvas();\n\n        return (\n            <div className='imageAreas'>\n                <div className='canvas'>\n                    <div className='title'>{title}</div>\n                    <canvas width={width} height={height} ref={canvasRef} onClick={handleMouseClick}>\n                    </canvas>\n                </div>\n            </div>\n        );\n    } else {\n        return <div className='imageAreas'>\n            <div className='canvas'>\n                <div className='title'>{title}</div>\n                <div>Error loading</div>\n            </div>\n        </div>\n    }\n}\n\nexport default ImageAreas;","import React from 'react';\nimport { useRef, useState, useEffect } from 'react';\nimport ImageAreas from \"./ImageAreas\";\n\nimport './SectionPages.scss';\n\nfunction SectionPages({ images, pages, sectionPageAreas, skipScrollingFromTime, onPageClicked }) {\n    const [zoom, setZoom] = useState(1);\n    const [lastScrollHash, setLastScrollHash] = useState(\"\");\n    const sectionPagesRef = useRef();\n\n    const handleZoomIn = () => {\n        setZoom(zoom + 0.1);\n    }\n\n    const handleZoomOut = () => {\n        setZoom(zoom - 0.1);\n    }\n\n    const handleReset = () => {\n        setZoom(1);\n    }\n\n    const findFirstSelectedPageIdx = () => {\n        var selectedPageIdx = -1;\n        for (var idx = 0; idx < pages.length; idx++) {\n            const puid = pages[idx].id;\n            if (sectionPageAreas[puid] && sectionPageAreas[puid].length) {\n                selectedPageIdx = idx;\n                break;\n            }\n        }\n        return selectedPageIdx;\n    }\n\n    const findScrollareaNode = () => {\n        for (var i = 0; i < sectionPagesRef.current.childNodes.length; i++) {\n            if (sectionPagesRef.current.childNodes[i].className == 'scrollArea') {\n                return sectionPagesRef.current.childNodes[i];\n            }\n        }\n        throw 'Cannot find scrollArea';\n    }\n\n    const findPageNode = (selectedPageIdx) => {\n        var container = findScrollareaNode();\n        var invariant = 0;\n        for (var i = 0; i < container.childNodes.length; i++) {\n            if (container.childNodes[i].className == \"page\") {\n                if (invariant == selectedPageIdx) {\n                    return container.childNodes[i];\n                }\n                invariant ++;\n            }\n        }\n        throw \"cannot find page \" + selectedPageIdx;\n    }\n\n    const onImageClicked = (imageIdx, imageX, imageY) => {\n        const pageId = pages[imageIdx].id;\n        onPageClicked(pageId, imageX, imageY);\n    }\n\n    const calculatePageHeight = () =>\n        parseInt(500*zoom*297/210 + 20);\n\n    const calculatePageWidth = () =>\n        parseInt(500*zoom + 20);\n\n    const shouldSkipScrolling = () =>\n        skipScrollingFromTime && ((new Date().getTime() - skipScrollingFromTime) < 2000);\n\n    const handleScrolling = () => {\n        const hash = JSON.stringify(sectionPageAreas);\n        if (lastScrollHash != hash && sectionPagesRef.current) {\n            var updateHash = true;\n            const selectedPageIdx = findFirstSelectedPageIdx();\n            if (selectedPageIdx >= 0) {\n                var page = findPageNode(selectedPageIdx);\n                if (!shouldSkipScrolling()) {\n                    sectionPagesRef.current.scrollTop = page.offsetTop - findScrollareaNode().offsetTop;\n                }\n                if (page.offsetTop == 0) {\n                    updateHash = false;\n                }\n                if (!shouldSkipScrolling() && Object.keys(sectionPageAreas).length > 1) {\n                    sectionPagesRef.current.scrollTop += parseInt(calculatePageHeight() / 2);\n                }\n            }\n            if (updateHash) {\n                setLastScrollHash(hash);\n            }\n        }\n    }\n\n    useEffect(handleScrolling, []);\n    handleScrolling();\n\n    const sectionPagesStyles = {\n        height: calculatePageHeight() + \"px\",\n        width: calculatePageWidth() + \"px\"\n    }\n\n    return <div>\n        <div className='sectionPages' ref={sectionPagesRef} style={sectionPagesStyles}>\n            <div className='zoom'>\n                <img src='https://images2.imgbox.com/22/21/4gO3I6ii_o.png?download=true' width='32' onClick={handleZoomIn} />\n                <img src='https://images2.imgbox.com/1b/b2/L4tgMq2a_o.png?download=true' width='32' onClick={handleZoomOut} />\n                <img src='https://images2.imgbox.com/f3/d5/paRxNKm0_o.png?download=true' width='32' onClick={handleReset} />\n            </div>\n            <div className='scrollArea'>\n            {pages.map((p, idx) => {\n                return <div className='page' key={\"sectionpage\" + idx}>\n                            <ImageAreas\n                                title={`Page #${idx+1}`}\n                                image={images[idx]}\n                                onImageClicked={((imageX, imageY) => onImageClicked(idx, imageX, imageY)).bind(this)}\n                                width = {parseInt(500 * zoom)} areas={sectionPageAreas[p.id] || [] }\n                            />\n                        </div>;\n            })}\n            </div>\n        </div>\n    </div>;\n};\n\nexport default SectionPages;\n","import React, { useState, useRef } from 'react';\nimport ReactPlayerWrapper from '../ReactPlayerWrapper';\nimport Sections from './Sections';\n\nimport SectionPages from \"./SectionPages\";\n\nimport './Player.scss';\n\nfunction Player({ sections, images, pages, videoUrl }) {\n    const [activeSections, setActiveSections] = useState([]);\n    const [initialised, setInitialised] = useState(false)\n    const [skipScrollingFromTime, setSkipScrollingFromTime] = useState(false)\n    const [refreshSkipScrollingOnPlay, setRefreshSkipScrollingOnPlaying] = useState(false)\n    const [videoPlayerPosSecs, setVideoPlayerPosSecs] = useState(0);\n    const [playInput, setPlayInput] = useState(\"\");\n\n    const $player = useRef(null);\n\n    const handlePlayInterval = (from, until) => {\n        $player.current.playSection(from, until)\n    };\n\n    const updateActiveSections = (playedSeconds) => {\n        var newActiveSections = [];\n        sections.forEach((section, idx) => {\n            if (section.startSec <= playedSeconds && section.endSec >= playedSeconds) {\n                newActiveSections.push(idx);\n            }\n        });\n        setActiveSections(newActiveSections);\n    }\n\n    const onProgressUpdate = (playedSeconds) => {\n        setVideoPlayerPosSecs(parseFloat(playedSeconds.toFixed(1)));\n        if (refreshSkipScrollingOnPlay) {\n            setSkipScrollingFromTime(new Date().getTime());\n            setRefreshSkipScrollingOnPlaying(false);\n        }\n        updateActiveSections(playedSeconds);\n    };\n\n    const onPlay = () => {\n        setInitialised(true)\n    }\n\n    const onStop = () => {\n        setSkipScrollingFromTime(false);\n        setRefreshSkipScrollingOnPlaying(false);\n    }\n\n    const getActivePageAreas = () => {\n        var areas = {};\n        activeSections.forEach(sectionIdx => {\n            for (const pageId in sections[sectionIdx].pageAreas) {\n                const pageAreas = sections[sectionIdx].pageAreas[pageId];\n                if (areas[pageId]) {\n                    areas[pageId] = areas[pageId].concat(pageAreas)\n                } else {\n                    areas[pageId] = pageAreas;\n                }\n            }\n        });\n        return areas;\n    }\n\n    const sectionContainsPoint = (pageAreas, posX, posY) => {\n        for (var areaIdx = 0; areaIdx < pageAreas.length; areaIdx++) {\n            const {x, y, width, height} = pageAreas[areaIdx];\n            const x2 = x + width;\n            const y2 = y + height;\n            if (posX > Math.min(x, x2) && posX < Math.max(x, x2) && posY > Math.min(y, y2) && posY < Math.max(y, y2)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    const onPageClicked = (pageUid, pageX, pageY) => {\n        for (var sectionIdx = 0 ; sectionIdx < sections.length; sectionIdx ++) {\n            const section = sections[sectionIdx];\n            if (sectionContainsPoint(section.pageAreas[pageUid] || [], pageX, pageY)) {\n                setPlayInput((sectionIdx + 1) + ':' + (sectionIdx + 1));\n                setRefreshSkipScrollingOnPlaying(true);\n                setSkipScrollingFromTime(new Date().getTime());\n                updateActiveSections(section.startSec);\n                handlePlayInterval(section.startSec, section.endSec);\n                return;\n            }\n        }\n    }\n\n    return (\n            <div className={initialised ? 'player' : 'player notInitialised'}>\n                <div className='sectionPagesWrapper'>\n                    <SectionPages\n                        images={images}\n                        pages={pages || []}\n                        onPageClicked={onPageClicked}\n                        skipScrollingFromTime={skipScrollingFromTime}\n                        sectionPageAreas={getActivePageAreas()}\n                        />\n                </div>\n\n                <div className='playerAndSections'>\n                    <ReactPlayerWrapper videoUrl={videoUrl} onProgressUpdate={onProgressUpdate} ref={$player} onPlay={onPlay} onStop={onStop} />\n                    <Sections sections={sections} playInterval={handlePlayInterval} activeSections={activeSections} playInput={playInput} setPlayInput={setPlayInput}/>\n                </div>\n\n            </div>\n    );\n}\n\nexport default Player;\n","import React, {useState , useEffect} from 'react';\n\n\nexport default ( { imageUrls, onImagesLoaded }) => {\n    const [progress, setProgress] = useState(new Array(imageUrls.length).fill(0));\n\n    useEffect(() => {\n        const progress = new Array(imageUrls.length).fill(0);\n\n        const interval = setInterval(() => {\n            const delta = parseInt(Math.random() * 3);\n            for (var idx = 0; idx < progress.length; idx++) {\n                progress[idx] += delta;\n                if (progress[idx] > 50) {\n                    progress[idx] -= parseInt(delta/2);\n                }\n                if (progress[idx] > 100) {\n                    progress[idx] = 100;\n                }\n            }\n            setProgress(JSON.parse(JSON.stringify(progress)));\n        }, 500);\n\n        var totalLoaded = 0;\n        const onImageLoaded = (idx) => {\n            progress[idx] = 100;\n            setProgress(JSON.parse(JSON.stringify(progress)));\n            totalLoaded += 1;\n            if (totalLoaded >= imageUrls.length) {\n                onImagesLoaded(images);\n                clearInterval(interval);\n            }\n        }\n\n        const images = imageUrls.map((imageUrl, idx) => {\n            const image = new Image();\n            image.src= imageUrl;\n            image.onload = () => { onImageLoaded(idx) }\n            image.onerror = (e) => { console.error(e); onImageLoaded(idx) }\n            return image;\n        });\n\n    }, []);\n\n    const renderProgress = () => {\n        const percent = parseInt(progress.reduce((prevVal, currVal) => prevVal + currVal, 0) / Math.max(0, progress.length));\n        return parseInt(progress.reduce((prevVal, currVal) => prevVal + currVal, 0) / Math.max(0, progress.length)) + \"%\" +\n            (percent == 100 ? '...' : '');\n    }\n\n    return <div>Loading {renderProgress()}</div>;\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport Player from './player/Player';\nimport { transformFromHumanReadable} from \"emptybars-common/utils\";\nimport { initSectionsPlayer } from \"emptybars-common/initialiser\";\n\nimport ImagesLoader from './ImagesLoader';\n\ninitSectionsPlayer(($element, data) => {\n\n    const onImagesLoaded = (images) => {\n        return ReactDOM.render(\n                    <React.StrictMode>\n                        <Player images={images} {...transformFromHumanReadable(data)} />\n                    </React.StrictMode>,\n                    $element\n                );\n    }\n\n    ReactDOM.render(\n        <React.StrictMode>\n            <ImagesLoader imageUrls={data.pages.map(p => p.url)} onImagesLoaded={onImagesLoaded} />\n        </React.StrictMode>,\n        $element\n    );\n});\n\n"],"sourceRoot":""}