{"version":3,"sources":["ReactPlayerWrapper.js","player/Fragments.js","player/ImageAreas.js","player/FragmentPages.js","player/Player.js","ImagesLoader.js","index.js"],"names":["ReactPlayerWrapper","props","state","progress","duration","gotoAfterStopSec","endSec","playing","$player","React","createRef","this","setState","current","seekTo","playedSeconds","_stopAndReturn","onProgressUpdate","startSec","mode","Math","max","className","ref","url","videoUrl","width","height","onDuration","_handleDuration","bind","onProgress","_handleProgress","onPlay","_handleOnPlay","progressInterval","onPause","_handleStop","onEnded","controls","config","youtube","playerVars","origin","window","location","secsToString","Component","Fragments","fragments","playInterval","activeFragments","useState","playInput","setPlayInput","onPlayInputChange","e","target","value","handleClickFragment","fragmentIdx","parseFragmentPoint","str","split","join","number","parseInt","length","console","error","secondsShift","trim","isNaN","parseFloat","isNumeric","parsePlayInput","fromFragmentStr","untilFragmentStr","fromFragment","fromFragmentDelta","untilFragment","untilFragmentDelta","map","key","indexOf","onClick","onChange","startFragmentIdx","startFragmentIdxDelta","stopFragmentIdx","stopFragmentIdxDelta","ImageAreas","coeffOrigImageToScreenCoords","title","image","areas","canvasRef","useRef","drawCanvas","context","getContext","drawImage","forEach","a","idx","fillStyle","fillRect","x","y","useEffect","FragmentPages","images","pages","fragmentPageAreas","fragmentPages","zoom","setZoom","lastScrollHash","setLastScrollHash","fragmentPagesRef","hash","JSON","stringify","selectedPage","puid","id","page","container","firstChild","invariant","i","childNodes","scrollIntoView","fragmentPagesStyles","style","p","Player","setActiveFragments","setVideoPlayerPosSecs","activePages","concat","getActivePages","pageId","pageAreas","getActivePageAreas","toFixed","newActiveFragments","fragment","push","from","until","playFragment","imageUrls","onImagesLoaded","Array","fill","setProgress","interval","setInterval","delta","random","parse","totalLoaded","onImageLoaded","clearInterval","imageUrl","Image","src","onload","onerror","percent","reduce","prevVal","currVal","renderProgress","fragmentsPlayer","initialized","document","getElementById","reload","data","innerHTML","parent","parentNode","remove","$element","ReactDOM","render","StrictMode","transformFromHumanReadable","ImagesLoader","InitPlayer"],"mappings":"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","file":"static/js/main.082cf206.chunk.js","sourcesContent":["import React, { useState, useRef, useEffect } from 'react';\nimport ReactPlayer from 'react-player';\n\nimport { secsToString } from 'emptybars-common/utils'\n\nimport './ReactPlayerWrapper.scss';\n\nclass ReactPlayerWrapper extends React.Component {\n\n    constructor(props) {\n        super(props);\n        this.state = {\n            progress: -1,\n            duration: -1,\n            gotoAfterStopSec: -1,\n            endSec: -1,\n            playing: true,\n        };\n        this.$player = React.createRef();\n    }\n\n    _handleDuration(duration) {\n        this.setState({duration: duration});\n    }\n\n    _stopAndReturn() {\n        const gotoAfterStopSec = this.state.gotoAfterStopSec;\n        this.setState({\n            endSec: -1,\n            gotoAfterStopSec: -1,\n            playing: false\n        });\n        this.$player.current.seekTo(gotoAfterStopSec, 'seconds');\n    }\n\n    _handleProgress({ playedSeconds }) {\n        if (this.state.endSec > 0 && playedSeconds > this.state.endSec) {\n            this._stopAndReturn();\n        }\n        this.setState({progress: playedSeconds});\n        this.props.onProgressUpdate(playedSeconds);\n    };\n\n    _handleOnPlay() {\n        this.setState({playing: true});\n    }\n\n    _handleStop() {\n        this.setState({playing: false});\n    }\n\n    playFragment(startSec, endSec, mode) {\n        this.$player.current.seekTo(startSec, 'seconds');\n        this.setState({\n            // TODO: remove magic strings\n            gotoAfterStopSec: Math.max(mode === 'STAY_AT_END' ? endSec : startSec, 0),\n            endSec: Math.max(endSec, 0.01),\n            playing: true\n        });\n    }\n\n    render() {\n            return (\n                <div className='playWithNavButtons'>\n                    <ReactPlayer\n                        ref={this.$player}\n                        url={this.props.videoUrl}\n                        width='100%'\n                        height='100%'\n                        onDuration={this._handleDuration.bind(this)}\n                        onProgress={this._handleProgress.bind(this)}\n                        onPlay={this._handleOnPlay.bind(this)}\n                        progressInterval={100}\n                        onPause={this._handleStop.bind(this)}\n                        onEnded={this._handleStop.bind(this)}\n                        playing={this.state.playing}\n                        controls={true}\n                        config={{\n                            youtube: {\n                                playerVars: {origin: window.location.origin}\n                            }\n                        }}\n                    />\n                    <div className='positionAndControls'>\n                        Current position: <span className='position'>{secsToString(this.state.progress)}</span>\n                    </div>\n                </div>\n            );\n    }\n}\n\nexport default ReactPlayerWrapper;","import React, {useState, useRef, useEffect} from 'react';\nimport { secsToString } from \"emptybars-common/utils\";\n\nimport './Fragments.scss';\n\nfunction Fragments({ fragments, playInterval, activeFragments }) {\n    const [playInput, setPlayInput] = useState(\"\");\n\n    const onPlayInputChange = (e) => {\n        setPlayInput(e.target.value);\n    }\n\n    const handleClickFragment = (fragmentIdx) => {\n        onPlayInputChange({\n            target: {\n                value: (fragmentIdx+1) + ':' + (fragmentIdx+1)\n            }\n        });\n        playInterval(fragments[fragmentIdx].startSec, fragments[fragmentIdx].endSec);\n    };\n\n    const handlePlayClick = () => {\n        const [startFragmentIdx, startFragmentIdxDelta, stopFragmentIdx, stopFragmentIdxDelta] = parsePlayInput(playInput);\n        playInterval(\n            fragments[startFragmentIdx-1].startSec + startFragmentIdxDelta,\n            fragments[stopFragmentIdx-1].endSec + stopFragmentIdxDelta\n        )\n    }\n\n    function isNumeric(str) {\n        if (typeof str != \"string\") return false // we only process strings!\n        return !isNaN(str) && // use type coercion to parse the _entirety_ of the string (`parseFloat` alone does not do this)...\n            !isNaN(parseFloat(str)) // ...and ensure strings of whitespace fail\n    }\n\n    const parseFragmentPoint = (str) => {\n        str = str.split('-').join('+-');\n        const split = str.split('+');\n        const number = parseInt(split[0]);\n        if (number != split[0]) {\n            return [false, false];\n        }\n        if (number <= 0 || number > fragments.length) {\n            console.error(\"Fragment \" + number + \" is out of range. Max=\" + fragments.length)\n            return [false, false];\n        }\n        if (split.length == 1) {\n            return [number, 0];\n        } else if (split.length == 2) {\n            const secondsShift = split[1].split('s').join('').trim()\n            if (!isNumeric(secondsShift)) {\n                console.error(secondsShift + \" is not a number\");\n                return [false, false];\n            }\n            return [number, parseFloat(secondsShift)];\n        } else {\n            return [false, false];\n        }\n    }\n\n    const parsePlayInput = (playInput) => {\n        const split = playInput.split(':');\n        if (split.length != 2) {\n            return false;\n        }\n        const fromFragmentStr = split[0];\n        const untilFragmentStr = split[1];\n        var [fromFragment, fromFragmentDelta] = parseFragmentPoint(fromFragmentStr);\n        if (!fromFragment) {\n            return false;\n        }\n        var [untilFragment, untilFragmentDelta] = parseFragmentPoint(untilFragmentStr);\n        if (!untilFragment) {\n            return false;\n        }\n        return [fromFragment, fromFragmentDelta, untilFragment, untilFragmentDelta];\n    }\n\n    return (\n        <div className='fragments'>\n            <div>Fragments:</div>\n            <div className='scrolling'>\n\n                {fragments.map(({ startSec, endSec }, key) => (\n                    <div\n                        className={`button ${\n                            (activeFragments.indexOf(key) >= 0) ? 'active' : ''\n                        }`}\n                        key={key}\n                        onClick={handleClickFragment.bind(null, key)}\n                    >\n                        #{key+1}\n                    </div>\n                ))}\n            </div>\n            <div>Play fragments: <input onChange={onPlayInputChange} value={playInput}/></div>\n            {!parsePlayInput(playInput)\n                ? <div>\n                    <div className=\"error\">Invalid format!</div>\n                    <div>Allowed formats: <br/>\n                        <span>1:1</span> - Play fragment 1 <br/>\n                        <span>1:3</span> - Play fragments 1, 2 and 3<br/>\n                        <span>1-10s:2+15.2s</span> - Play fragments 1 and 2; start 10 seconds earlier and finish 15.2\n                        seconds later\n                    </div>\n                </div>\n                : <button onClick={handlePlayClick}>Play</button>\n            }\n         </div>);\n}\n\nexport default Fragments;\n","import React, { useState, useRef, useEffect } from 'react';\n\nimport './ImageAreas.scss';\n\nfunction ImageAreas({ title, image, width, areas }) {\n    // var [height, setHeight] = useState(100);\n    var canvasRef = useRef(null);\n    var coeffOrigImageToScreenCoords;\n    var height;\n\n    if (image && image.width && image.height) {\n        coeffOrigImageToScreenCoords = (width * 1.0 / image.width);\n        height = parseInt(image.height * coeffOrigImageToScreenCoords);\n    } else {\n        coeffOrigImageToScreenCoords = -1;\n        height = -1;\n    }\n\n    const drawCanvas = () => {\n        if (image && image.width && image.height && canvasRef && canvasRef.current) {\n            const context = canvasRef.current.getContext(\"2d\");\n            context.drawImage(image, 0, 0, image.width, image.height, 0, 0, width, height);\n\n            areas.forEach((a, idx) => {\n                context.fillStyle = 'rgba(255, 255, 0, 0.5)';\n                context.fillRect(a.x * coeffOrigImageToScreenCoords, a.y * coeffOrigImageToScreenCoords, a.width * coeffOrigImageToScreenCoords, a.height * coeffOrigImageToScreenCoords);\n            });\n        }\n    }\n\n    useEffect(() => {\n        drawCanvas();\n    });\n\n    if (image && image.width && image.height) {\n        drawCanvas();\n\n        return (\n            <div className='imageAreas'>\n                <div className='canvas'>\n                    <div className='title'>{title}</div>\n                    <canvas width={width} height={height} ref={canvasRef}>\n                    </canvas>\n                </div>\n            </div>\n        );\n    } else {\n        return <div className='imageAreas'>\n            <div className='canvas'>\n                <div className='title'>{title}</div>\n                <div>Error loading</div>\n            </div>\n        </div>\n    }\n}\n\nexport default ImageAreas;","import React from 'react';\nimport { useRef, useState } from 'react';\nimport ImageAreas from \"./ImageAreas\";\n\nimport './FragmentPages.scss';\n\nfunction FragmentPages({ images, pages, fragmentPages, fragmentPageAreas }) {\n    const [zoom, setZoom] = useState(1);\n    const [lastScrollHash, setLastScrollHash] = useState(\"\");\n    const fragmentPagesRef = useRef();\n\n    const handleZoomIn = () => {\n        setZoom(zoom + 0.1);\n    }\n\n    const handleZoomOut = () => {\n        setZoom(zoom - 0.1);\n    }\n\n    const handleReset = () => {\n        setZoom(1);\n    }\n\n    const hash = JSON.stringify(fragmentPageAreas);\n    if (lastScrollHash != hash && fragmentPagesRef.current) {\n        setLastScrollHash(hash);\n        var selectedPage = -1;\n        for (var idx = 0; idx < pages.length; idx++) {\n            const puid = pages[idx].id;\n            if (fragmentPageAreas[puid] && fragmentPageAreas[puid].length) {\n                selectedPage = idx;\n                break;\n            }\n        }\n        if (selectedPage >= 0) {\n            var page = null;\n            var container = fragmentPagesRef.current.firstChild;\n            var invariant = 0;\n            for (var i = 0; i < container.childNodes.length; i++) {\n                if (container.childNodes[i].className == \"page\") {\n                    if (invariant == selectedPage) {\n                        page = container.childNodes[i];\n                        break;\n                    }\n                    invariant ++;\n                }\n            }\n            page.scrollIntoView();\n        }\n    }\n\n    // if (fragmentPagesRef && fragmentPagesRef.current) {\n    //     fragmentPagesRef.current.scrollTop = 100;\n    // }\n\n    const fragmentPagesStyles = {\n        height: parseInt(500*zoom*297/210 + 20) + \"px\"\n    }\n\n    return <div>\n        <div>Zoom: <span onClick={handleZoomIn}>+</span> <span onClick={handleZoomOut}>-</span> <span onClick={handleReset}>reset</span></div>\n        <div className='fragmentPages' ref={fragmentPagesRef} style={fragmentPagesStyles}>\n            <div className='scrollArea'>\n            {pages.map((p, idx) => {\n                return <div className='page' key={\"fragmentpage\" + idx}>\n                            <ImageAreas\n                                title={`Page #${idx+1}`}\n                                image={images[idx]}\n                                width = {parseInt(500 * zoom)} areas={fragmentPageAreas[p.id] || [] }\n                            />\n                        </div>;\n            })}\n            </div>\n        </div>\n    </div>;\n};\n\nexport default FragmentPages;\n","import React, { useState, useRef } from 'react';\nimport ReactPlayerWrapper from '../ReactPlayerWrapper';\nimport Fragments from './Fragments';\n\nimport FragmentPages from \"./FragmentPages\";\n\nimport './Player.css';\n\nfunction Player({ fragments, images, pages, videoUrl }) {\n    const [activeFragments, setActiveFragments] = useState([]);\n    const [videoPlayerPosSecs, setVideoPlayerPosSecs] = useState(0);\n\n    const $player = useRef(null);\n\n    const handlePlayInterval = (from, until) => {\n        $player.current.playFragment(from, until)\n    };\n\n    const onProgressUpdate = (playedSeconds) => {\n        setVideoPlayerPosSecs(parseFloat(playedSeconds.toFixed(1)));\n        var newActiveFragments = [];\n        fragments.forEach((fragment, idx) => {\n            if (fragment.startSec <= playedSeconds && fragment.endSec >= playedSeconds) {\n                newActiveFragments.push(idx);\n            }\n        });\n        setActiveFragments(newActiveFragments);\n    };\n\n    const getActivePages = () => {\n        var activePages = [];\n        activeFragments.forEach(fragmentIdx => {\n            activePages = activePages.concat(fragments[fragmentIdx].pages);\n        });\n        return activePages;\n    }\n\n    const getActivePageAreas = () => {\n        var areas = {};\n        activeFragments.forEach(fragmentIdx => {\n            for (const pageId in fragments[fragmentIdx].pageAreas) {\n                const pageAreas = fragments[fragmentIdx].pageAreas[pageId];\n                if (areas[pageId]) {\n                    areas[pageId] = areas[pageId].concat(pageAreas)\n                } else {\n                    areas[pageId] = pageAreas;\n                }\n            }\n        });\n        return areas;\n    }\n\n    return (\n            <div className='player'>\n                <div>\n                    <FragmentPages\n                        images={images}\n                        pages={pages || []}\n                        fragmentPages={getActivePages()}\n                        fragmentPageAreas={getActivePageAreas()}\n                        />\n                </div>\n\n                <div>\n                    <ReactPlayerWrapper videoUrl={videoUrl} onProgressUpdate={onProgressUpdate} ref={$player} />\n                    <Fragments fragments={fragments} playInterval={handlePlayInterval} activeFragments={activeFragments}/>\n                </div>\n\n            </div>\n    );\n}\n\nexport default Player;\n","import React, {useState , useEffect} from 'react';\n\n\nexport default ( { imageUrls, onImagesLoaded }) => {\n    const [progress, setProgress] = useState(new Array(imageUrls.length).fill(0));\n\n    useEffect(() => {\n        const progress = new Array(imageUrls.length).fill(0);\n\n        const interval = setInterval(() => {\n            const delta = parseInt(Math.random() * 3);\n            for (var idx = 0; idx < progress.length; idx++) {\n                progress[idx] += delta;\n                if (progress[idx] > 50) {\n                    progress[idx] -= parseInt(delta/2);\n                }\n                if (progress[idx] > 100) {\n                    progress[idx] = 100;\n                }\n            }\n            setProgress(JSON.parse(JSON.stringify(progress)));\n        }, 500);\n\n        var totalLoaded = 0;\n        const onImageLoaded = (idx) => {\n            progress[idx] = 100;\n            setProgress(JSON.parse(JSON.stringify(progress)));\n            totalLoaded += 1;\n            if (totalLoaded >= imageUrls.length) {\n                onImagesLoaded(images);\n                clearInterval(interval);\n            }\n        }\n\n        const images = imageUrls.map((imageUrl, idx) => {\n            const image = new Image();\n            image.src= imageUrl;\n            image.onload = () => { onImageLoaded(idx) }\n            image.onerror = (e) => { console.error(e); onImageLoaded(idx) }\n            return image;\n        });\n\n    }, []);\n\n    const renderProgress = () => {\n        const percent = parseInt(progress.reduce((prevVal, currVal) => prevVal + currVal, 0) / Math.max(0, progress.length));\n        return parseInt(progress.reduce((prevVal, currVal) => prevVal + currVal, 0) / Math.max(0, progress.length)) + \"%\" +\n            (percent == 100 ? '...' : '');\n    }\n\n    return <div>Loading {renderProgress()}</div>;\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport Player from './player/Player';\nimport { transformFromHumanReadable} from \"emptybars-common/utils\";\n\nimport ImagesLoader from './ImagesLoader';\n\nwindow.fragmentsPlayer = {\n    initialized: false,\n    interval: false\n};\n\nwindow.fragmentsPlayer.interval = setInterval(() => {\n    if (document.getElementById('playerData')) {\n        if (window.fragmentsPlayer.initialized) {\n            clearInterval(window.fragmentsPlayer.interval);\n            window.location.reload();\n            return;\n        }\n        window.fragmentsPlayer.initialized = true;\n        const data = JSON.parse(document.getElementById('playerData').innerHTML);\n        const parent = document.getElementById('playerData').parentNode;\n        document.getElementById('playerData').remove();\n        InitPlayer(parent, data);\n    }\n}, 100);\n\nfunction InitPlayer($element, data) {\n\n    const onImagesLoaded = (images) => {\n        return ReactDOM.render(\n                    <React.StrictMode>\n                        <Player images={images} {...transformFromHumanReadable(data)} />\n                    </React.StrictMode>,\n                    $element\n                );\n    }\n\n    ReactDOM.render(\n        <React.StrictMode>\n            <ImagesLoader imageUrls={data.pages.map(p => p.url)} onImagesLoaded={onImagesLoaded} />\n        </React.StrictMode>,\n        $element\n    );\n}\n\n"],"sourceRoot":""}